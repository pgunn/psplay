#!/usr/bin/python

import argparse
import json
import lockfile
import os
import re
import subprocess
import sys

###########
# psplay_client is the "client" component of psplay - it runs frequently from
# cron, and iterates over all registered splaykeys for this system. Registered
# by config management.
#
# Operational model:
#	A splaykey (skey) is used to define host-specific splay for 1+
#		services that use that splaykey
#	psplay_client schedules "atservices" at defined times using the
#		appropriate splaykey and the atservice definition as a factor
#		for when things run
#	Splaykeys come from outside the system, and psplay_client responds
#		to those by adjusting when things run, in a way that's kind to
#		the reasons people splay in the first place
#
# For each such splaykey:
#	Read the old attribute from the local cache (if present!)
#	Read the new attribute from mdb (if present!)
#	Update the local cache
#	Reason about moratoriums statefully
#	Determine from those when it should next be scheduled
#	Determine if it already is so scheduled
#	If it is:
#		Everything is great
#	Otherwise:
#		Cancel any existing scheules of it
#		Schedule it correctly
#
# Data it works with:
#	machine tagging database - reads
#	moratorium file
#	old attribute cache
#	at - reads, schedules, cancels

def main():
	cfg = handle_args()
	morat = load_moratoria(cfg.morfile) # RO-cache
	mylock = get_lockfile(cfg.lockfile)
	for skey in get_skey_list(cfg.sdefdir):
		sdef = load_sdef(skey, cfg.sdefdir) # RO-cache
		# Process this host's skeys
		expire_old_moratoriums(skey, morat, cfg.morfile)
		oldval = get_offset_for_skey_cache(skey)
		newval = get_offset_for_skey_mtag(skey)
		if oldval != newval: # Be careful comparing fractions!
			cache_setval(skey, newval)
			for service in services_linked_to_key(sdef):
				if atservice_scheduled(skey, service):
					deschedule_atservice(service)
			if newval < oldval:
				set_moratorium(skey, newval, morat, cfg.morfile)
		if (! in_moratorium(skey, morat)):
			for service in services_linked_to_key(skey):
				if !atservice_scheduled(skey, service):
					schedule_atservice(service)
	release_lockfile(mylock)

def handle_args():
	# cfg.cachefile
	# cfg.morfile - moratorium file (no user servicable parts)
	# cfg.sdefdir - service definition dir
	pass


###################
# service definition operations
#
# Long-term storage is a directory of config files, one per skey
# Each config file defines a hash of hashes:
#	atservice_name =>
#		'cmd' => command
#		'offset' => offset (seconds)
#		'freq' => frequency_definition (in seconds)
#
# load_sdef() will load one of these and, parsing each one and returning
# a data structure that matches that. These functions are READONLY; they
# only consume service definitions; defs are written by some external
# process (such as a config management tool). 
#
# A lot of therse are accessors, but it's easier to change how a function
# works than rework stuff that looks like base language plumbing

def get_skey_list(dir):
	""" Return all defined service keys """
	maybe = os.listdir(dir)
	ret = []
	for mayb in maybe: # Ignore non-json files
		if '.json' in mayb:
			ret.extend(re.sub(r'\.json$', '', mayb))
	return ret

def load_sdef(skey, cfgdir):
	with open(cfgdir + '/' + skey + '.json') as jfile:
		sdef = json.load(jfile)
	return sfef

def services_linked_to_key(sdef):
	return sdef.keys()

def get_atservice_offset(sdef, atsvc):
	return sdef[atsvc]['offset']

def get_atservice_offset(skey, atsvc):
	""" Return offset-in-seconds that this host will run this atservice at.
	We don't do anything clever with modulus operations; scheduler
	functions will handle that """
	return get_skey_offset_for_this_host(skey) + get_atservice_offset(atsvc)

####
# And the scheduling-specific parts of that

def deschedule_atservice(service):
	pass

def schedule_atservice(service):
	pass

def atservice_scheduled(skey, service):
	pass

###################
# moratorium operations
#
# Long-term storage is in a json file, but we'll load/parse a RO copy
# when the program starts up. The file is a simple hash:
#	skey => epochtime
# epochtime being when the moratorium expires

def load_moratoria(mfile):
	with open(mfile, 'r') as mfh:
		ret = json.load(mfh)
	return ret

def set_moratorium(skey, oldval, newval, mcache, mfile):
	mcache[skey] = newval
	with open(mfile, 'w') as mfh:
		json.dump(mcache, mfile)

def expire_old_moratoriums(skey, mcache, mdir):
	pass

def in_moratorium(skey, mcache):
	pass


###################
# low-level at operations

###################
# local mtag cache operations

def get_offset_for_skey_cache(skey):
	pass

def cache_setval(skey, newval):
	pass

###################
# mtag operations

def get_offset_for_skey_mtag(skey):
	pass

###################
# lockfile operations

def get_lockfile(lf):
	# See psplay_server
	lock = LockFile(lf)
	lock.acquire(timeout=30) # seconds
	return lock

def release_lockfile(lock):
	lock.release()

###################

main()
