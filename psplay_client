#!/usr/bin/python

import argparse
import lockfile
import subprocess
import sys

###########
# psplay_client is the "client" component of psplay - it runs frequently from
# cron, and iterates over all registered splaykeys for this system. Registered
# by config management.
#
# Operational model:
#	A splaykey (skey) is used to define host-specific splay for 1+
#		services that use that splaykey
#	psplay_client schedules "atservices" at defined times using the
#		appropriate splaykey and the atservice definition as a factor
#		for when things run
#	Splaykeys come from outside the system, and psplay_client responds
#		to those by adjusting when things run, in a way that's kind to
#		the reasons people splay in the first place
#
# For each such splaykey:
#	Read the old attribute from the local cache (if present!)
#	Read the new attribute from mdb (if present!)
#	Update the local cache
#	Reason about moratoriums statefully
#	Determine from those when it should next be scheduled
#	Determine if it already is so scheduled
#	If it is:
#		Everything is great
#	Otherwise:
#		Cancel any existing scheules of it
#		Schedule it correctly
#
# Data it works with:
#	machine tagging database - reads
#	moratorium file
#	old attribute cache
#	at - reads, schedules, cancels

def main():
	cfg = handle_args()
	morat = load_moratoria(cfg.mordir) # RO-cache
	mylock = get_lockfile(cfg.lockfile)
	for skey in get_skey_list():
		sdef = load_sdef(skey, cfg.sdefdir) # RO-cache
		# Process this host's skeys
		expire_old_moratoriums(skey, morat, cfg.mordir)
		oldval = get_offset_for_skey_cache(skey)
		newval = get_offset_for_skey_mtag(skey)
		if oldval != newval: # Be careful comparing fractions!
			cache_setval(skey, newval)
			for service in services_linked_to_key(skey):
				if atservice_scheduled(skey, service):
					deschedule_atservice(service)
			if newval < oldval:
				set_moratorium(skey, oldval, newval, morat, cfg.mordir)
		if (! in_moratorium(skey, morat)):
			for service in services_linked_to_key(skey):
				if !atservice_scheduled(skey, service):
					schedule_atservice(service)
	release_lockfile(mylock)

def handle_args():
	# cfg.cachefile
	# cfg.mordir - moratorium dir (no user servicable parts)
	# cfg.sdefdir - service definition dir
	pass


###################
# service definition operations
#
# Long-term storage is a directory of config files, one per skey
# Each config file defines a hash of hashes:
#	atservice_name =>
#		'cmd' => command
#		'offset' => offset
#		'freq' => frequency_definition (in seconds)
#
# load_sdef() will load one of these and, parsing each one and returning
# a data structure that matches that. This tool only consumes service
# definitions; these are written by some external process (such as a config
# management tool). 

def load_sdef(skey, cfgdir):
	pass

def get_skey_list():
	pass

def services_linked_to_key(skey):
	pass

def deschedule_atservice(service):
	pass

def schedule_atservice(service):
	pass

def atservice_scheduled(skey, service):
	pass

def get_service_offset(skey, service):
	return (get_skey_value(skey) * get_skey_offset_for_this_host(skey)) +
		get_service_offset(service)


###################
# moratorium operations
#
# Long-term storage is in a directory, but we'll load/parse a RO copy
# when the program starts up. The directory has one file per skey

def set_moratorium(skey, oldval, newval, mcache, mdir):
	pass

def expire_old_moratoriums(skey, mcache, mdir):
	pass

def in_moratorium(skey, mcache):
	pass

def load_moratoria(mdir):
	pass

###################
# at operations

###################
# cfgdir operations

###################
# local mtag cache operations

def get_offset_for_skey_cache(skey):
	pass

def cache_setval(skey, newval):
	pass

###################
# mtag operations

def get_offset_for_skey_mtag(skey):
	pass

###################
# lockfile operations

def get_lockfile(lf):
	# See psplay_server
	lock = LockFile(lf)
	lock.acquire(timeout=30) # seconds
	return lock

def release_lockfile(lock):
	lock.release()

###################

main()
